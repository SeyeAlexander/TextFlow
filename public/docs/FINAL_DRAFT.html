<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>FlowDesk — Frontend Architecture & Implementation Plan</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400&display=swap");
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family:
          "Inter",
          -apple-system,
          sans-serif;
        font-size: 10.5pt;
        line-height: 1.55;
        color: #1a1a1a;
        max-width: 720px;
        margin: 0 auto;
        padding: 36px 28px;
      }
      h1 {
        font-size: 16pt;
        font-weight: 700;
        margin-bottom: 22px;
        border-bottom: 2px solid #111;
        padding-bottom: 6px;
      }
      h2 {
        font-size: 12pt;
        font-weight: 700;
        margin-top: 22px;
        margin-bottom: 8px;
      }
      h3 {
        font-size: 10.5pt;
        font-weight: 600;
        margin-top: 14px;
        margin-bottom: 4px;
        color: #333;
      }
      p {
        margin-bottom: 8px;
      }
      strong {
        font-weight: 600;
      }
      em {
        font-style: italic;
        color: #555;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 8px 0 12px;
        font-size: 10pt;
      }
      th {
        background: #f5f5f5;
        font-weight: 600;
        text-align: left;
        padding: 6px 8px;
        border: 1px solid #ddd;
      }
      td {
        padding: 5px 8px;
        border: 1px solid #ddd;
        vertical-align: top;
      }
      code {
        font-family: "JetBrains Mono", monospace;
        font-size: 9pt;
        background: #f4f4f4;
        padding: 1px 3px;
        border-radius: 2px;
      }
      pre {
        background: #f8f8f8;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        padding: 10px 12px;
        margin: 8px 0 12px;
        font-family: "JetBrains Mono", monospace;
        font-size: 8.5pt;
        line-height: 1.45;
        color: #333;
      }
      ul,
      ol {
        margin: 4px 0 10px 18px;
      }
      li {
        margin-bottom: 4px;
      }
      hr {
        border: none;
        border-top: 1px solid #ddd;
        margin: 18px 0;
      }
      @media print {
        body {
          padding: 16px;
          font-size: 10pt;
          max-width: 100%;
        }
        h1 {
          font-size: 14pt;
        }
        h2 {
          font-size: 11pt;
          page-break-after: avoid;
        }
        pre {
          font-size: 8pt;
          page-break-inside: avoid;
        }
        table {
          page-break-inside: avoid;
        }
      }
    </style>
  </head>
  <body>
    <h1>FlowDesk — Frontend Architecture &amp; Implementation Plan</h1>

    <h2>A. High-Level Estimation</h2>

    <p>
      <strong>2–3 days</strong> to deliver production-ready, assuming designs are finalized and APIs
      behave as documented.
    </p>

    <table>
      <thead>
        <tr>
          <th>Phase</th>
          <th>Scope</th>
          <th>Time</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Day 1</td>
          <td>Route setup, API layer, table with pagination, filters, sorting</td>
          <td>~6–8h</td>
        </tr>
        <tr>
          <td>Day 2</td>
          <td>Detail drawer, full detail page, TanStack Query integration</td>
          <td>~6–8h</td>
        </tr>
        <tr>
          <td>Day 3</td>
          <td>Loading/error/empty states, motion polish, edge cases, a11y</td>
          <td>~4–6h</td>
        </tr>
      </tbody>
    </table>

    <p>
      I'd sync with the designer early on the drawer vs. full-page layout since it shapes the
      component structure. If Figma-to-code tooling is available, Day 1 can compress significantly.
    </p>

    <p><strong>Milestones:</strong></p>
    <ul>
      <li>
        <strong>M1</strong> (end of Day 1) — CSM can view paginated data, search, filter, and sort.
        Core value delivered.
      </li>
      <li>
        <strong>M2</strong> (end of Day 2) — Drawer opens with real data, full detail page is
        navigable. Feature functionally complete.
      </li>
      <li>
        <strong>M3</strong> (end of Day 3) — Edge cases handled, states polished, transitions
        smooth. Ready for QA.
      </li>
    </ul>

    <p>
      <strong>Key dependencies:</strong> finalized designs, API availability, design system
      documentation.
    </p>

    <hr />

    <h2>B. Architecture &amp; Component Structure</h2>

    <h3>Routes &amp; Components</h3>

    <pre>
app/(dashboard)/customer-health/
├── page.tsx          # Server — fetches list via searchParams
├── loading.tsx       # Table skeleton (Suspense boundary)
├── error.tsx         # Route-level error UI
└── [customerId]/
    ├── page.tsx      # Server — full customer detail
    ├── loading.tsx
    └── error.tsx

components/customers/
├── customer-health-table.tsx     # Client — table with sorting
├── customer-row.tsx              # Client — row with click handler
├── health-badge.tsx              # Shared — color-coded status
├── filters-toolbar.tsx           # Client — search, filter, sort
├── customer-detail-drawer.tsx    # Client — side panel (Sheet)
├── overview-cards.tsx            # Shared — metric cards
└── empty-state.tsx               # Shared — configurable empty/error</pre
    >

    <p>
      <strong>Server Components</strong> (<code>page.tsx</code> files) handle data fetching —
      reduces bundle size, eliminates waterfalls, HTML arrives with data.
      <strong>Client Components</strong> (toolbar, drawer, row handlers) handle interactivity —
      search input, filters, drawer state, chart rendering.
    </p>

    <h3>Progressive Detail Disclosure</h3>

    <p>
      The spec mentions "right-side panel (or route)" — I'm proposing <strong>both</strong>. When a
      CSM clicks a row, a <strong>shadcn Sheet</strong> slides in from the right with rounded
      corners and breathing room (margins on all sides). It shows the essentials: health score, MRR,
      last active, recent notes — the CSM can scan multiple customers without leaving the table.
    </p>

    <p>
      A <strong>"View Full Details →"</strong> button at the top-right of the drawer navigates to
      <code>/customer-health/[customerId]</code> — a dedicated page with color-coded overview cards
      (MRR, Usage %, Last Activity, Health Score), Recharts usage trend charts, and a recent events
      table. Charts live on the detail page only to keep the list view fast.
    </p>

    <p>
      <strong>Stack:</strong> shadcn/ui (Table, Sheet, Select, Input, Badge, Pagination), Framer
      Motion for smooth transitions, Recharts for charts.
    </p>

    <hr />

    <h2>C. Data Fetching &amp; State Management</h2>

    <p>
      <strong>Customer list (server-side):</strong> Standard Next.js <code>fetch</code> in the
      Server Component. All list state (page, sort, search, segment) lives in
      <strong>URL search params</strong> — single source of truth, survives refresh, supports back
      button, shareable. Pagination is server-side — 10 results by default, option for 20 or 30.
      Client-side pagination of large datasets is a non-starter.
    </p>

    <p>
      <strong>Customer details (client-side):</strong> TanStack Query via
      <code>useCustomerHealth(customerId)</code>. Caching means reopening the same customer is
      instant. Independent loading/error states per panel — the drawer never blocks the table. Root
      <code>providers.tsx</code> with sensible defaults (stale time, retry on 5xx only, no refetch
      on window focus). API functions in <code>lib/api/</code>, hooks in <code>hooks/</code> — keeps
      things testable.
    </p>

    <p>
      <strong>Loading:</strong> <code>loading.tsx</code> skeletons mimicking the table/detail
      structure (no spinners). <strong>Errors:</strong> <code>error.tsx</code> boundaries per route
      + drawer-level retry. <strong>Empty:</strong> Reusable <code>EmptyState</code> component with
      configurable title, icon, and CTAs ("Clear Filters", "Go back").
    </p>

    <hr />

    <h2>D. UX Details &amp; Edge Cases</h2>

    <p>
      <strong>Slow networks:</strong> Filter/pagination navigations wrapped in
      <code>useTransition</code> — current data stays visible (dimmed) while next batch loads.
      Drawer loads independently from the list. <strong>Search:</strong> Debounced at 300ms using
      <code>router.replace</code> (not <code>push</code>) to avoid polluting browser history.
      <strong>Sorting:</strong> Columns sortable by Health Score, MRR, Last Active, Owner — header
      click toggles asc/desc/none in the URL. <strong>Filters:</strong> Health segment dropdown as
      baseline; URL param structure designed to support future compound filters without refactoring.
      <strong>Scroll:</strong> <code>{ scroll: false }</code> on pagination to prevent viewport
      jumping.
    </p>

    <p><strong>Edge cases:</strong></p>
    <ol>
      <li><strong>Empty results</strong> — "No customers found" with "Clear Filters" button.</li>
      <li>
        <strong>Page out of range after filtering</strong> — auto-reset to page 1 when filters
        change.
      </li>
      <li>
        <strong>Race conditions</strong> — TanStack Query's keyed queries prevent stale data from
        rendering in the wrong panel; in-flight requests cancel on unmount.
      </li>
      <li><strong>Missing data</strong> — null fields show "N/A" instead of crashing.</li>
      <li><strong>Long customer names</strong> — truncate with tooltip.</li>
      <li>
        <strong>Stale tab</strong> — subtle "Data may be outdated" banner after extended idle.
      </li>
      <li>
        <strong>Detail fetch fails</strong> — drawer shows its own error; table stays fully
        functional.
      </li>
    </ol>

    <hr />

    <h2>E. Task Breakdown</h2>

    <p>
      I prefer a <strong>vertical slice</strong> approach — each task is shippable and demo-able.
      These can be broken into individual tickets on a board like Linear or ClickUp:
    </p>

    <ol>
      <li>
        <strong>Route setup, API layer, and core table</strong> — Both routes with loading/error
        boundaries. Table with pagination, filters (debounced search, segment dropdown), and sorting
        — all URL-synced. Wire to real API. <em>(~6–8h)</em>
      </li>
      <li>
        <strong>Detail drawer and data integration</strong> — shadcn Sheet on row click. TanStack
        Query provider + <code>useCustomerHealth</code> hook. "View Full Details →" link.
        <em>(~3–4h)</em>
      </li>
      <li>
        <strong>Full detail page</strong> — <code>/customer-health/[customerId]</code> with overview
        cards, Recharts charts, events table. <em>(~3h)</em>
      </li>
      <li>
        <strong>Polish and edge cases</strong> — Skeletons, error/empty states, Framer Motion
        transitions, a11y pass (keyboard nav, focus trap, ARIA). <em>(~3–4h)</em>
      </li>
    </ol>

    <hr />

    <p>
      The architecture favors clarity, incremental delivery, and real-world resilience — each day
      ends with something shippable. Happy to walk through any of this in more detail.
    </p>
  </body>
</html>
